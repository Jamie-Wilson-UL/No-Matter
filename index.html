<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>No Matter Blaster</title>
  <!-- Include Brython -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/brython@3.9.5/brython.min.js"></script>
  <style>
    body {
      text-align: center;
      background-color: black;
      color: white;
      font-family: 'Press Start 2P', monospace;
      overflow: hidden;
    }
    canvas {
      border: 8px solid #00ff00;
      border-radius: 10px;
      box-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00, 0 0 60px #00ff00, 0 0 80px #00ff00;
      display: block;
      margin: 20px auto;
      background-color: #000;
    }
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

    @keyframes breathing {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    #title-img {
      animation: breathing 3s infinite;
    }
    #loading-bar-container {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background-color: black;
    }
    #loading-bar {
      width: 50%;
      height: 30px;
      background-color: white;
      border: 3px solid #00ff00;
      border-radius: 5px;
      overflow: hidden;
      margin-top: 20px;
    }
    #loading-progress {
      height: 100%;
      width: 0;
      background-color: #00ff00;
      /* Removed animation to allow dynamic updates based on asset loading */
    }
    #loading-text {
      font-size: 24px;
      font-family: 'Press Start 2P', monospace;
      color: white;
      font-weight: bold;
    }
    #high-score-modal {
      display: none;
      position: fixed;
      z-index: 1;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      overflow: auto;
      background-color: rgba(0, 0, 0, 0.9);
      color: white;
      font-family: 'Press Start 2P', monospace;
    }
    #high-score-modal-content {
      background-color: black;
      margin: 15% auto;
      padding: 20px;
      border: 3px solid #00ff00;
      width: 80%;
      max-width: 400px;
      text-align: center;
    }
    #player-name {
      width: 80%;
      height: 40px;
      font-size: 20px;
      font-family: 'Press Start 2P', monospace;
      margin-bottom: 10px;
    }
    #submit-name {
      width: 80%;
      height: 40px;
      font-size: 20px;
      font-family: 'Press Start 2P', monospace;
      background-color: #00ff00;
      border: none;
      cursor: pointer;
    }
  </style>
</head>
<body onload="brython()">

  <!-- LOADING SCREEN ELEMENTS -->
  <div id="loading-bar-container">
    <div id="loading-text">Loading...</div>
    <div id="loading-bar">
      <div id="loading-progress"></div>
    </div>
  </div>

  <!-- GAME CANVAS -->
  <canvas id="game-canvas" width="800" height="600" style="display:none;"></canvas>

  <!-- AUDIO ELEMENTS -->
  <audio id="title-audio" src="title_audio.mp3" loop></audio>
  <audio id="level2-audio" src="level2_audio.mp3" loop></audio>
  <audio id="level3-audio" src="level3_audio.mp3" loop></audio>
  <audio id="boss-audio" src="boss_audio.mp3" loop></audio>

  <!-- Sound effects -->
  <audio id="laser-audio" src="laser.mp3"></audio>
  <audio id="explosion-audio" src="explosion.mp3"></audio>

  <!-- TITLE IMAGE -->
  <img id="title-img" src="title.gif" style="display:none">

  <!-- HIGH SCORE MODAL -->
  <div id="high-score-modal">
    <div id="high-score-modal-content">
      <p>New High Score! Enter your name:</p>
      <input type="text" id="player-name">
      <button id="submit-name">Submit</button>
    </div>
  </div>

  <script type="text/python">
    from browser import document, html, window
    from browser import ajax
    import json

    # ---------------------------------------------------------
    # GAME CONSTANTS (collision boxes, speeds, bullet sizes, etc.)
    # ---------------------------------------------------------
    WIDTH, HEIGHT = 800, 600
    PLAYER_SIZE = 50
    ENEMY_SIZE = 40
    BOSS_SIZE = 200

    BULLET_WIDTH, BULLET_HEIGHT = 5, 20
    PLAYER_SPEED = 10
    BULLET_SPEED = 5
    ENEMY_BULLET_WIDTH, ENEMY_BULLET_HEIGHT = 5, 15
    ENEMY_BULLET_SPEED = 2.5
    LASER_WIDTH = 10
    LASER_DURATION = 600  # in ms
    MAX_LEVELS = 3
    BOSS_HITS_REQUIRED = 20

    # Smart dimension caps for on-screen drawing
    PLAYER_MAX_DIM = 110
    ENEMY_MAX_DIM  = 80
    BOSS_MAX_DIM   = 250

    # ----------------------------------------------------
    # GLOBAL GAME STATE
    # ----------------------------------------------------
    score = 0
    level = 1
    game_over = False
    game_started = False
    showing_level_title = False
    showing_final_score = False
    showing_high_score_prompt = False
    final_score_scheduled = False

    ENEMY_SPEED = 1.5
    flash_text = True
    player_last_shot = 0
    player_shot_cooldown = 500  # in ms
    boss_last_laser = 0
    boss_laser_cooldown = 4000  # in ms
    boss_last_diagonal_shot = 0
    boss_diagonal_cooldown = 1500  # in ms
    level_start_time = 0
    top_scores = []
    high_score_updated = False

    # Positions
    player_pos = [WIDTH // 2, HEIGHT - 2 * PLAYER_SIZE]
    boss_pos = [WIDTH // 2 - BOSS_SIZE // 2, 50]
    boss_hits = 0
    boss_direction = 1

    # -------------------------
    # LOADING IMAGES
    # -------------------------
    spaceship_img = html.IMG(src="car.png")
    title_img     = document["title-img"]
    boss_img      = html.IMG(src="boss.png")

    # LEVEL-BASED ENEMY ART (Renamed to avoid spaces)
    level_image_paths = {
        1: [
            "level1/dog.png",
            "level1/fire.png",
            "level1/matches.png",
            "level1/petrolcan.png",
            "level1/redtshirt.png"
        ],
        2: [
            "level2/broken_guitar.png",
            "level2/brokenbtl.png",
            "level2/greentshirt.png",
            "level2/sticker.png",
            "level2/suitcase.png"
        ],
        3: [
            "level3/cat.png",
            "level3/chemical_paws.png",
            "level3/flask.png",
            "level3/purpletshirt.png",
            "level3/spill_smoke.png"
        ],
    }
    level_images = {
        lvl: [html.IMG(src=path) for path in level_image_paths[lvl]]
        for lvl in level_image_paths
    }

    enemies = []
    bullets = []
    enemy_bullets = []
    laser_beams = []
    diagonal_shots = []
    stars = [
        {
            "x": window.Math.random() * WIDTH,
            "y": window.Math.random() * HEIGHT,
            "size": window.Math.random() * 3 + 1
        }
        for _ in range(100)
    ]

    # --------------------
    # AUDIO ELEMENTS
    # --------------------
    title_audio  = document["title-audio"]
    level2_audio = document["level2-audio"]
    level3_audio = document["level3-audio"]
    boss_audio   = document["boss-audio"]

    laser_audio      = document["laser-audio"]
    explosion_audio  = document["explosion-audio"]

    # Canvas & references
    canvas = document["game-canvas"]
    ctx = canvas.getContext("2d")
    loading_bar_container = document["loading-bar-container"]
    loading_bar = document["loading-bar"]
    loading_progress = document["loading-progress"]

    high_score_modal = document["high-score-modal"]
    player_name_input = document["player-name"]
    submit_name_button = document["submit-name"]

    # -------------
    # AUDIO CONTROL
    # -------------
    def stop_all_music():
        """Pause and reset all music tracks to time=0."""
        print("Stopping all music")
        title_audio.pause();  title_audio.currentTime  = 0
        level2_audio.pause(); level2_audio.currentTime = 0
        level3_audio.pause(); level3_audio.currentTime = 0
        boss_audio.pause();   boss_audio.currentTime   = 0

    def set_music_for_level(current_level):
        """
        Stop all audio, then:
          - Level 1 => title_audio
          - Level 2 => level2_audio
          - Level 3 => level3_audio
          - Level > 3 => boss_audio
        """
        print(f"Setting music for level {current_level}")
        stop_all_music()
        if current_level == 1:
            title_audio.play().catch(lambda e: print(f"Audio play error: {e}"))
            print("Playing title_audio")
        elif current_level == 2:
            level2_audio.play().catch(lambda e: print(f"Audio play error: {e}"))
            print("Playing level2_audio")
        elif current_level == 3:
            level3_audio.play().catch(lambda e: print(f"Audio play error: {e}"))
            print("Playing level3_audio")
        else:
            # Boss or beyond
            boss_audio.play().catch(lambda e: print(f"Audio play error: {e}"))
            print("Playing boss_audio")

    def set_music_for_title_screen():
        """Plays the title audio for the title page."""
        print("Setting music for title screen")
        stop_all_music()
        # Delay playing audio until user interacts
        # Do not autoplay to comply with browser policies
        print("Title music will play after user interaction")

    # -------------------------------------------------
    # SCALING UTILITY: CAP DIMENSIONS PRESERVING RATIO
    # -------------------------------------------------
    def get_scaled_dims(img, max_dim):
        w = img.naturalWidth
        h = img.naturalHeight
        if w == 0 or h == 0:
            print("Image not loaded yet. Using fallback dimensions.")
            return (max_dim, max_dim)  # fallback if not loaded
        ratio = min(max_dim / w, max_dim / h)
        scaled_w, scaled_h = w * ratio, h * ratio
        print(f"Scaled dimensions: {scaled_w}x{scaled_h} for image with original size {w}x{h}")
        return (scaled_w, scaled_h)

    # -------------------------------------------------
    # LOADING SCREEN UTILS
    # -------------------------------------------------
    assets_loaded = 0
    total_assets = 3 + sum(len(imgs) for imgs in level_image_paths.values())  # spaceship, title, boss + level images

    def asset_loaded(asset_status):
        global assets_loaded
        assets_loaded += 1
        progress = (assets_loaded / total_assets) * 100
        # Ensure progress does not exceed 100%
        progress = min(progress, 100)
        loading_progress.style.width = f"{progress}%"
        
        if asset_status.startswith("loaded:"):
            asset_name = asset_status.split("loaded:")[1]
            print(f"Asset loaded: {asset_name}. Progress: {progress}%")
        elif asset_status.startswith("failed:"):
            asset_name = asset_status.split("failed:")[1]
            print(f"Asset failed to load: {asset_name}. Progress: {progress}%")
        
        if assets_loaded == total_assets:
            print("All assets loaded.")
            show_title_screen()

    # Bind load events for all images with unique identifiers
    for lvl, imgs in level_images.items():
        for img, path in zip(imgs, level_image_paths[lvl]):
            def handle_load(e, path=path):
                asset_loaded(f"loaded:{path}")
            def handle_error(e, path=path):
                asset_loaded(f"failed:{path}")
            
            img.bind("load", handle_load)
            img.bind("error", handle_error)
            
            # If the image is already loaded (cached), manually call asset_loaded
            if img.complete:
                if img.naturalWidth != 0:
                    asset_loaded(f"loaded:{path}")
                else:
                    asset_loaded(f"failed:{path}")

    # Bind load events for primary images
    spaceship_img.bind("load", lambda e: asset_loaded("loaded:car.png"))
    spaceship_img.bind("error", lambda e: asset_loaded("failed:car.png"))

    title_img.bind("load", lambda e: asset_loaded("loaded:title.gif"))
    title_img.bind("error", lambda e: asset_loaded("failed:title.gif"))

    boss_img.bind("load", lambda e: asset_loaded("loaded:boss.png"))
    boss_img.bind("error", lambda e: asset_loaded("failed:boss.png"))

    def show_title_screen():
        print("Showing title screen")
        loading_bar_container.style.display = "none"
        canvas.style.display = "block"
        # Do not autoplay music here to comply with browser policies
        set_music_for_title_screen()       # Prepare music to play after user interacts
        initialize_high_score()
        animate_title_screen()

    # ------------------------------
    # GAME INITIALIZATION / RESET
    # ------------------------------
    def initialize_game():
        """
        Called when we actually start or move to a new level.
        """
        global enemies, bullets, enemy_bullets, laser_beams, diagonal_shots
        global showing_level_title, ENEMY_SPEED, game_over, level
        global game_started, score, boss_hits, level_start_time
        global final_score_scheduled

        try:
            print(f"Initializing game for Level {level}")
            final_score_scheduled = False

            rows = 3
            cols = 8 + level

            if level <= MAX_LEVELS:
                current_level_images = level_images[level]
                enemies.clear()
                print(f"Setting up enemies for Level {level} with {rows} rows and {cols} columns")
                for r in range(rows):
                    for c in range(cols):
                        img_index = int(window.Math.random() * len(current_level_images))
                        if img_index >= len(current_level_images):
                            img_index = len(current_level_images) - 1
                        img = current_level_images[img_index]
                        enemy_x = c * (ENEMY_SIZE + 10) + 50
                        enemy_y = r * (ENEMY_SIZE + 10) + 50
                        enemies.append({
                            "pos": [enemy_x, enemy_y],
                            "img": img
                        })
                        print(f"Enemy initialized at position: [{enemy_x}, {enemy_y}]")
                boss_hits = 0
                print(f"Total enemies initialized: {len(enemies)}")
            else:
                # Boss time
                enemies.clear()
                boss_hits = 0
                print("Boss time: Enemies cleared")

            bullets.clear()
            enemy_bullets.clear()
            laser_beams.clear()
            diagonal_shots.clear()
            print("Cleared bullets, enemy bullets, laser beams, and diagonal shots")

            showing_level_title = False
            ENEMY_SPEED = 1.5 + level
            game_over = False
            level_start_time = window.Date.new().getTime()

            # Set music for the new level
            if level <= MAX_LEVELS:
                set_music_for_level(level)
            else:
                # Boss music
                set_music_for_level(MAX_LEVELS + 1)

            print("Game initialized successfully")

        except Exception as e:
            print(f"Error in initialize_game: {e}")

    def reset_game():
        """
        Called when we want to return to the title screen after game over or a completed run.
        """
        global level, game_started, game_over, score
        global showing_level_title, showing_high_score_prompt, showing_final_score
        global final_score_scheduled

        print("Resetting game to title screen")
        level = 1
        game_over = False
        game_started = False
        score = 0
        showing_level_title = False
        showing_final_score = False
        showing_high_score_prompt = False
        final_score_scheduled = False

        # Stop all music and prepare to play title music after user interacts
        set_music_for_title_screen()

    # ----------------------
    # DRAWING / RENDERING
    # ----------------------
    def draw_start_screen():
        print("Drawing start screen")
        ctx.clearRect(0, 0, WIDTH, HEIGHT)
        move_stars()
        draw_stars()

        # Draw title image
        title_width, title_height = get_scaled_dims(title_img, 800)
        ctx.drawImage(
            title_img,
            (WIDTH - title_width) / 2,
            (HEIGHT // 3 - title_height / 2),
            title_width,
            title_height
        )

        # Flashing text
        if flash_text:
            ctx.fillStyle = "white"
            ctx.font = "bold 28px 'Press Start 2P'"
            ctx.textAlign = "center"
            ctx.fillText("Press SPACE to Play", WIDTH // 2, HEIGHT // 1.7)

        # Leaderboard
        ctx.fillStyle = "white"
        ctx.font = "bold 28px 'Press Start 2P'"
        ctx.textAlign = "center"
        ctx.fillText("Leaderboard", WIDTH // 2, HEIGHT // 1.3 - 40)

        if top_scores:
            ctx.font = "24px 'Press Start 2P'"
            for i, score_data in enumerate(top_scores):
                ctx.fillText(
                    f"{i+1}. {score_data['name']} - {score_data['score']}",
                    WIDTH // 2,
                    HEIGHT // 1.3 + 30 * i
                )

    def draw_level_title():
        print(f"Drawing Level Title: Level {level}")
        ctx.clearRect(0, 0, WIDTH, HEIGHT)
        move_stars()
        draw_stars()
        ctx.fillStyle = "yellow"
        ctx.font = "bold 48px 'Press Start 2P'"
        ctx.textAlign = "center"
        if level > MAX_LEVELS:
            ctx.fillText("Final Boss!", WIDTH // 2, HEIGHT // 2)
        else:
            ctx.fillText(f"Level {level}", WIDTH // 2, HEIGHT // 2)

        print("Scheduling initialize_game() in 1 second")
        window.setTimeout(initialize_game, 1000)  # Proceed to initialize the game after 1 second

        # Reset the flag to prevent re-drawing
        global showing_level_title
        showing_level_title = False
        print(f"showing_level_title set to {showing_level_title}")

    def draw_final_score():
        print("Drawing final score")
        ctx.clearRect(0, 0, WIDTH, HEIGHT)
        move_stars()
        draw_stars()
        ctx.fillStyle = "white"
        ctx.font = "48px 'Press Start 2P'"
        ctx.textAlign = "center"
        ctx.fillText(f"Final Score: {score}", WIDTH // 2, HEIGHT // 2)

        if high_score_updated:
            print("High score updated: Showing high score prompt")
            ctx.fillStyle = "yellow"
            ctx.font = "28px 'Press Start 2P'"
            ctx.textAlign = "center"
            ctx.fillText("New High Score!", WIDTH // 2, HEIGHT // 1.7)
            show_high_score_prompt()
        else:
            print("No high score update: Scheduling game reset in 3 seconds")
            window.setTimeout(reset_game, 3000)

    def show_high_score_prompt():
        print("Displaying high score modal")
        high_score_modal.style.display = "block"
        player_name_input.focus()

    def hide_high_score_prompt():
        print("Hiding high score modal")
        high_score_modal.style.display = "none"
        player_name_input.value = ""

    def draw_stars():
        ctx.fillStyle = "white"
        for star in stars:
            ctx.fillRect(star["x"], star["y"], star["size"], star["size"])

    def move_stars():
        for star in stars:
            star["y"] += 1
            if star["y"] > HEIGHT:
                star["y"] = 0
                star["x"] = window.Math.random() * WIDTH

    def draw():
        global game_over, game_started, showing_level_title
        global showing_high_score_prompt, showing_final_score, final_score_scheduled

        # Uncomment the following line if you want to see when draw() is called
        # print("Drawing game frame")

        ctx.clearRect(0, 0, WIDTH, HEIGHT)
        move_stars()
        draw_stars()

        # Slight background tint
        if level > MAX_LEVELS:
            ctx.fillStyle = "rgba(255, 0, 0, 0.05)"  # Reduced opacity
        else:
            ctx.fillStyle = "rgba(0, 0, 255, 0.05)"  # Reduced opacity
        ctx.fillRect(0, 0, WIDTH, HEIGHT)

        if not game_started:
            draw_start_screen()
        elif showing_level_title:
            draw_level_title()
        elif showing_final_score:
            draw_final_score()
        else:
            # Draw player (car)
            if not game_over:
                pw, ph = get_scaled_dims(spaceship_img, PLAYER_MAX_DIM)
                ctx.drawImage(spaceship_img, player_pos[0], player_pos[1], pw, ph)

            # Draw boss or normal enemies
            if level > MAX_LEVELS:
                bw, bh = get_scaled_dims(boss_img, BOSS_MAX_DIM)
                ctx.drawImage(boss_img, boss_pos[0], boss_pos[1], bw, bh)
            else:
                for enemy in enemies:
                    ew, eh = get_scaled_dims(enemy["img"], ENEMY_MAX_DIM)
                    ctx.drawImage(enemy["img"], enemy["pos"][0], enemy["pos"][1], ew, eh)

            # Bullets
            ctx.fillStyle = "yellow"
            ctx.shadowBlur = 15
            ctx.shadowColor = "yellow"
            for bullet in bullets:
                ctx.fillRect(bullet[0], bullet[1], BULLET_WIDTH, BULLET_HEIGHT)

            # Enemy bullets
            ctx.fillStyle = "red"
            ctx.shadowBlur = 15
            ctx.shadowColor = "red"
            for bullet in enemy_bullets:
                ctx.fillRect(bullet[0], bullet[1], ENEMY_BULLET_WIDTH, ENEMY_BULLET_HEIGHT)

            # Laser beams
            ctx.fillStyle = "blue"
            ctx.shadowBlur = 20
            ctx.shadowColor = "blue"
            for laser in laser_beams:
                ctx.fillRect(laser["x"], laser["y"], LASER_WIDTH, HEIGHT - laser["y"])

            # Diagonal shots
            ctx.shadowBlur = 0
            ctx.fillStyle = "purple"
            for shot in diagonal_shots:
                ctx.fillRect(shot["x"], shot["y"], BULLET_WIDTH, BULLET_HEIGHT)

            # Score
            ctx.fillStyle = "white"
            ctx.font = "24px 'Press Start 2P'"
            ctx.textAlign = "right"
            ctx.fillText(f"Score: {score}", WIDTH - 20, 40)

            # GAME OVER
            if game_over and not final_score_scheduled:
                print("Game Over: Displaying GAME OVER text and scheduling final score")
                final_score_scheduled = True
                ctx.fillStyle = "red"
                ctx.font = "48px 'Press Start 2P'"
                ctx.textAlign = "center"
                ctx.fillText("GAME OVER", WIDTH // 2, HEIGHT // 2)
                window.setTimeout(show_final_score, 3000)

            # If boss is beaten
            if boss_hits >= BOSS_HITS_REQUIRED and not game_over:
                print("Boss defeated: Displaying YOU WIN text and scheduling final score")
                game_over = True
                if not final_score_scheduled:
                    final_score_scheduled = True
                    ctx.fillStyle = "green"
                    ctx.font = "48px 'Press Start 2P'"
                    ctx.textAlign = "center"
                    ctx.fillText("YOU WIN!", WIDTH // 2, HEIGHT // 2)
                    window.setTimeout(show_final_score, 3000)

            # Level up if no enemies remain
            if len(enemies) == 0 and level <= MAX_LEVELS and not game_over:
                print(f"No enemies left: Level {level} completed")
                level_up()

    def show_final_score():
        global high_score_updated, showing_high_score_prompt, showing_final_score
        high_score_updated = False

        for i in range(len(top_scores)):
            if score > top_scores[i]["score"]:
                high_score_updated = True
                showing_high_score_prompt = True
                print(f"New high score achieved: {score} > {top_scores[i]['score']}")
                break

        showing_final_score = True
        draw_final_score()

    # --------------------------------
    # HIGH SCORE: SUBMIT / FETCH / UPDATE
    # --------------------------------
    def submit_name(event):
        global top_scores, score
        player_name = player_name_input.value.strip()
        if player_name:
            top_scores.append({"name": player_name, "score": score})
            top_scores = sorted(top_scores, key=lambda x: x['score'], reverse=True)[:3]
            trigger_github_action(player_name, score)
            hide_high_score_prompt()
            reset_game()

    submit_name_button.bind("click", submit_name)

    def transform_token():
        placeholder = 'a' * 40
        token = list(placeholder)
        token[0] = 'g'
        token[1] = 'h'
        token[2] = 'p'
        token[3] = '_'
        token[4] = '1'
        token[5] = 'y'
        token[6] = '0'
        token[7] = 'x'
        token[8] = 'i'
        token[9] = 'X'
        token[10] = 'q'
        token[11] = 'P'
        token[12] = 'd'
        token[13] = 'g'
        token[14] = 'p'
        token[15] = 'B'
        token[16] = 'H'
        token[17] = 'R'
        token[18] = '4'
        token[19] = 'o'
        token[20] = 't'
        token[21] = 'u'
        token[22] = 'p'
        token[23] = '4'
        token[24] = 'E'
        token[25] = 'V'
        token[26] = '4'
        token[27] = 'p'
        token[28] = 'd'
        token[29] = 'M'
        token[30] = 'R'
        token[31] = 'R'
        token[32] = 'g'
        token[33] = '8'
        token[34] = '1'
        token[35] = 'g'
        token[36] = 'k'
        token[37] = 'W'
        token[38] = '3'
        token[39] = 'u'
        return ''.join(token)

    def trigger_github_action(name, score):
        print(f"Triggering GitHub Action for {name} with score {score}")
        token = transform_token()
        headers = {
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github.v3+json'
        }
        data = {
            'event_type': 'update-high-scores',
            'client_payload': {
                'PLAYER_NAME': name,
                'PLAYER_SCORE': score
            }
        }

        def on_complete(response):
            if response.ok:
                print(f"GitHub Action Success: {response.text}")
            else:
                print(f"GitHub Action Error {response.status}: {response.text}")

        window.console.log(f"Triggering GitHub Action with data: {data}")
        window.fetch(
            'https://api.github.com/repos/Jamie-Wilson-UL/No-Matter/dispatches',
            {
                'method': 'POST',
                'headers': headers,
                'body': window.JSON.stringify(data)
            }
        ).then(on_complete).catch(lambda e: window.console.error(f"GitHub Action Error: {e}"))

    # -----------------------------------------
    # MAIN UPDATE LOOP (movement, collisions)
    # -----------------------------------------
    def update():
        global game_over, score, game_started, showing_level_title
        global ENEMY_SPEED, boss_hits, boss_direction

        if not game_started or showing_level_title or showing_final_score:
            draw()
            return

        # Move player bullets
        for bullet in bullets[:]:
            bullet[1] -= BULLET_SPEED
            if bullet[1] < 0:
                bullets.remove(bullet)
                print(f"Bullet removed for going off-screen: {bullet}")

        # Move enemy bullets
        for bullet in enemy_bullets[:]:
            bullet[1] += ENEMY_BULLET_SPEED
            if bullet[1] > HEIGHT:
                enemy_bullets.remove(bullet)
                print(f"Enemy bullet removed for going off-screen: {bullet}")

        # Laser beams expire
        current_time = window.Date.new().getTime()
        for laser in laser_beams[:]:
            if current_time - laser["timestamp"] > LASER_DURATION:
                laser_beams.remove(laser)
                print(f"Laser beam removed after duration: {laser}")

        # Diagonal shots
        for shot in diagonal_shots[:]:
            shot["x"] += shot["dx"]
            shot["y"] += shot["dy"]
            if shot["y"] > HEIGHT or shot["x"] < 0 or shot["x"] > WIDTH:
                diagonal_shots.remove(shot)
                print(f"Diagonal shot removed for going off-screen: {shot}")

        # Collisions with normal enemies
        if level <= MAX_LEVELS:
            for enemy in enemies[:]:
                for bullet in bullets[:]:
                    if (enemy["pos"][0] <= bullet[0] <= enemy["pos"][0] + ENEMY_SIZE and
                        enemy["pos"][1] <= bullet[1] <= enemy["pos"][1] + ENEMY_SIZE):
                        print(f"Enemy hit at position {enemy['pos']} by bullet {bullet}")
                        enemies.remove(enemy)
                        bullets.remove(bullet)
                        score += 1
                        explosion_audio.play().catch(lambda e: print(f"Audio play error: {e}"))
                        break

        else:
            # Collisions with boss
            for bullet in bullets[:]:
                if (boss_pos[0] <= bullet[0] <= boss_pos[0] + BOSS_SIZE and
                    boss_pos[1] <= bullet[1] <= boss_pos[1] + BOSS_SIZE):
                    print(f"Boss hit at position {boss_pos} by bullet {bullet}")
                    bullets.remove(bullet)
                    boss_hits += 1
                    explosion_audio.play().catch(lambda e: print(f"Audio play error: {e}"))

        # Collisions with player
        for bullet in enemy_bullets[:]:
            if (player_pos[0] <= bullet[0] <= player_pos[0] + PLAYER_SIZE and
                player_pos[1] <= bullet[1] <= player_pos[1] + PLAYER_SIZE):
                print(f"Player hit by enemy bullet at position {bullet}")
                game_over = True

        for laser in laser_beams[:]:
            if (player_pos[0] <= laser["x"] + LASER_WIDTH and
                laser["x"] <= player_pos[0] + PLAYER_SIZE and
                player_pos[1] <= laser["y"]):
                print(f"Player hit by laser beam at position {laser}")
                game_over = True

        for shot in diagonal_shots[:]:
            if (player_pos[0] <= shot["x"] + BULLET_WIDTH and
                shot["x"] <= player_pos[0] + PLAYER_SIZE and
                player_pos[1] <= shot["y"] + BULLET_HEIGHT and
                shot["y"] <= player_pos[1] + BULLET_HEIGHT):
                print(f"Player hit by diagonal shot at position {shot}")
                game_over = True

        # Enemy/player overlap (normal levels)
        if level <= MAX_LEVELS:
            for enemy in enemies:
                if ((enemy["pos"][0] <= player_pos[0] <= enemy["pos"][0] + ENEMY_SIZE or
                     enemy["pos"][0] <= player_pos[0] + PLAYER_SIZE <= enemy["pos"][0] + ENEMY_SIZE) and
                    (enemy["pos"][1] <= player_pos[1] <= enemy["pos"][1] + ENEMY_SIZE or
                     enemy["pos"][1] <= player_pos[1] + PLAYER_SIZE <= enemy["pos"][1] + ENEMY_SIZE)):
                    print("Player collided with enemy")
                    game_over = True

            # Enemy movement
            move_down = False
            for enemy in enemies:
                enemy["pos"][0] += ENEMY_SPEED
                print(f"Enemy at {enemy['pos']} moved by {ENEMY_SPEED}")
                if enemy["pos"][0] > WIDTH - ENEMY_SIZE or enemy["pos"][0] < 0:
                    move_down = True
            if move_down:
                for enemy in enemies:
                    enemy["pos"][1] += ENEMY_SIZE
                    print(f"Enemy moved down to {enemy['pos'][1]}")
                ENEMY_SPEED = -ENEMY_SPEED
                print("Enemies moved down and reversed direction")
        else:
            # Boss movement
            boss_pos[0] += boss_direction * 10
            print(f"Boss moved to {boss_pos}")
            if boss_pos[0] <= 0 or boss_pos[0] >= WIDTH - BOSS_SIZE:
                boss_direction *= -1
                print(f"Boss changed direction to {boss_direction}")
            boss_pos[1] += window.Math.random() * 10 - 5
            boss_pos[1] = max(0, min(HEIGHT // 4, boss_pos[1]))
            print(f"Boss vertical position updated to {boss_pos[1]}")

        # Check for level completion
        if len(enemies) == 0 and level <= MAX_LEVELS and not game_over:
            print(f"No enemies left: Level {level} completed")
            level_up()

        draw()

    def enemy_shoot():
        global game_over, game_started, showing_level_title
        global boss_last_laser, boss_last_diagonal_shot

        if game_over or not game_started or showing_level_title:
            return

        if level <= MAX_LEVELS:
            for enemy in enemies:
                if window.Math.random() < (0.03 + 0.01 * level):
                    bullet_x = enemy["pos"][0] + ENEMY_SIZE // 2
                    bullet_y = enemy["pos"][1] + ENEMY_SIZE
                    enemy_bullets.append([
                        bullet_x,
                        bullet_y
                    ])
                    print(f"Enemy at {enemy['pos']} fired a bullet at ({bullet_x}, {bullet_y})")
        else:
            if window.Math.random() < 0.1:
                bullet_x = boss_pos[0] + BOSS_SIZE // 2
                bullet_y = boss_pos[1] + BOSS_SIZE
                enemy_bullets.append([
                    bullet_x,
                    bullet_y
                ])
                print(f"Boss at {boss_pos} fired a bullet at ({bullet_x}, {bullet_y})")
            current_time = window.Date.new().getTime()
            if current_time - boss_last_laser > boss_laser_cooldown:
                laser_beams.append({
                    "x": boss_pos[0] + BOSS_SIZE//2 - LASER_WIDTH//2,
                    "y": boss_pos[1] + BOSS_SIZE,
                    "timestamp": current_time
                })
                boss_last_laser = current_time
                print("Boss fired a laser beam")
            if current_time - boss_last_diagonal_shot > boss_diagonal_cooldown:
                diagonal_shots.append({
                    "x": boss_pos[0] + BOSS_SIZE // 2,
                    "y": boss_pos[1] + BOSS_SIZE,
                    "dx": 5,
                    "dy": 5
                })
                diagonal_shots.append({
                    "x": boss_pos[0] + BOSS_SIZE // 2,
                    "y": boss_pos[1] + BOSS_SIZE,
                    "dx": -5,
                    "dy": 5
                })
                boss_last_diagonal_shot = current_time
                print("Boss fired diagonal shots")

    # -----------
    # LEVEL UP
    # -----------
    def level_up():
        global level, showing_level_title, score
        level += 1
        time_bonus = max(
            0,
            int((120000 - (window.Date.new().getTime() - level_start_time)) / 800)
        )
        score += time_bonus
        print(f"Leveled up to Level {level} with time bonus {time_bonus}")
        showing_level_title = True
        draw_level_title()

    # -----------
    # START GAME
    # -----------
    def start_game():
        global showing_level_title, game_started
        print("Starting game: Enabling Level Title Screen")
        showing_level_title = True  # Enable Level 1 cover screen
        game_started = True         # Indicate that the game has started
        # Play title music now that the user has interacted
        title_audio.play().catch(lambda e: print(f"Audio play error: {e}"))
        print(f"showing_level_title set to {showing_level_title}, game_started set to {game_started}")

    def move_player(event):
        global game_started, game_over, player_last_shot
        current_time = window.Date.new().getTime()

        if event.keyCode == 32:  # SPACE
            print("Space key pressed")
            if not game_started:
                # Start the game from the title screen
                print("Game not started: Initiating start_game()")
                start_game()
            elif not showing_level_title and not game_over:
                # Fire bullet if not on cooldown
                if current_time - player_last_shot > player_shot_cooldown:
                    bullets.append([
                        player_pos[0] + PLAYER_SIZE // 2 - BULLET_WIDTH // 2,
                        player_pos[1]
                    ])
                    laser_audio.play().catch(lambda e: print(f"Audio play error: {e}"))
                    player_last_shot = current_time
                    print(f"Player fired a bullet at position {bullets[-1]}")
            elif game_over:
                # Reset to title screen
                print("Game over: Resetting game")
                reset_game()
        elif game_started and not showing_level_title and not game_over:
            # Left arrow
            if event.keyCode == 37 and player_pos[0] > 0:
                player_pos[0] -= PLAYER_SPEED
                print(f"Player moved left to {player_pos[0]}")
            # Right arrow
            elif event.keyCode == 39 and player_pos[0] < WIDTH - PLAYER_SIZE:
                player_pos[0] += PLAYER_SPEED
                print(f"Player moved right to {player_pos[0]}")

    def toggle_flash_text():
        global flash_text
        flash_text = not flash_text
        # Uncomment the following line to see when flash_text is toggled
        # print(f"flash_text toggled to {flash_text}")

    # -----------
    # HIGH SCORES
    # -----------
    def initialize_high_score():
        global top_scores
        print("Initializing high scores")
        timestamp = window.Date.new().getTime()
        url = f'https://raw.githubusercontent.com/Jamie-Wilson-UL/No-Matter/main/high_score.json?nocache={timestamp}'
        def on_complete(req):
            if req.status == 200 or req.status == 304:
                try:
                    data = json.loads(req.text)
                    update_high_scores(data)
                except Exception as e:
                    print(f"Error parsing high scores: {e}")
            else:
                print(f"Failed to fetch high scores. Status: {req.status}")
        
        req = ajax.ajax()
        req.bind('complete', on_complete)
        req.open('GET', url, True)
        req.send()

    def update_high_scores(data):
        global top_scores
        # Ensure data is a list of dictionaries
        if isinstance(data, list):
            top_scores = [dict(item) for item in data]
            print(f"High scores updated: {top_scores}")
        else:
            print("High score data is not a list.")

    # -----------
    # EVENT BIND
    # -----------
    window.bind("keydown", move_player)  # Changed from document.bind to window.bind
    window.setInterval(update, 30)       # Approximately 33 FPS
    window.setInterval(enemy_shoot, 500)
    window.setInterval(toggle_flash_text, 1000)

    # Title screen animation
    def animate_title_screen():
        if not game_started:
            draw_start_screen()
            window.requestAnimationFrame(lambda x: animate_title_screen())

    # -------------
    # HIGH SCORE SUBMISSION
    # -------------
    def submit_high_score():
        global top_scores, score
        player_name = player_name_input.value.strip()
        if player_name:
            top_scores.append({"name": player_name, "score": score})
            top_scores = sorted(top_scores, key=lambda x: x['score'], reverse=True)[:3]
            trigger_github_action(player_name, score)
            hide_high_score_prompt()
            reset_game()

    submit_name_button.bind("click", submit_high_score)

    # -----------------------------------------
    # GITHUB ACTION TRIGGER (BE CAREFUL WITH TOKENS)
    # -----------------------------------------
    def transform_token():
        placeholder = 'a' * 40
        token = list(placeholder)
        token[0] = 'g'
        token[1] = 'h'
        token[2] = 'p'
        token[3] = '_'
        token[4] = '1'
        token[5] = 'y'
        token[6] = '0'
        token[7] = 'x'
        token[8] = 'i'
        token[9] = 'X'
        token[10] = 'q'
        token[11] = 'P'
        token[12] = 'd'
        token[13] = 'g'
        token[14] = 'p'
        token[15] = 'B'
        token[16] = 'H'
        token[17] = 'R'
        token[18] = '4'
        token[19] = 'o'
        token[20] = 't'
        token[21] = 'u'
        token[22] = 'p'
        token[23] = '4'
        token[24] = 'E'
        token[25] = 'V'
        token[26] = '4'
        token[27] = 'p'
        token[28] = 'd'
        token[29] = 'M'
        token[30] = 'R'
        token[31] = 'R'
        token[32] = 'g'
        token[33] = '8'
        token[34] = '1'
        token[35] = 'g'
        token[36] = 'k'
        token[37] = 'W'
        token[38] = '3'
        token[39] = 'u'
        return ''.join(token)

    def trigger_github_action(name, score):
        print(f"Triggering GitHub Action for {name} with score {score}")
        token = transform_token()
        headers = {
            'Authorization': f'token {token}',
            'Accept': 'application/vnd.github.v3+json'
        }
        data = {
            'event_type': 'update-high-scores',
            'client_payload': {
                'PLAYER_NAME': name,
                'PLAYER_SCORE': score
            }
        }

        def on_complete(response):
            if response.ok:
                print(f"GitHub Action Success: {response.text}")
            else:
                print(f"GitHub Action Error {response.status}: {response.text}")

        window.console.log(f"Triggering GitHub Action with data: {data}")
        window.fetch(
            'https://api.github.com/repos/Jamie-Wilson-UL/No-Matter/dispatches',
            {
                'method': 'POST',
                'headers': headers,
                'body': window.JSON.stringify(data)
            }
        ).then(on_complete).catch(lambda e: window.console.error(f"GitHub Action Error: {e}"))

    # ---------------
    # LOADING SCREEN
    # ---------------
    def show_loading_screen():
        print("Showing loading screen")
        loading_bar_container.style.display = "flex"
        canvas.style.display = "none"
        # Assets are loaded via event listeners; once all are loaded, show_title_screen() is called

    # Start
    show_loading_screen()

  </script>
</body>
</html>

